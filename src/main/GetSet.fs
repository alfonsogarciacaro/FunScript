module internal FunScript.GetSet

open AST
open System.Reflection
open Microsoft.FSharp.Quotations
open Microsoft.FSharp.Reflection
open Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions

let private fieldGetSet com _  = function
   | Patterns.FieldGet(target, fi) ->
      // Autogenerated fields will be suffixed with @
      let fiName = fi.Name.Replace("@", "") |> String
      match target with
         | Some (CompileExpr com target) -> PropertyGet(target, fiName)
         | None -> PropertyGet(com.RefType fi.DeclaringType, fiName)
      |> buildExpr
   | Patterns.FieldSet(target, fi, CompileExpr com value) as expr ->
      let fiName = fi.Name.Replace("@", "") |> String
      match target with
         | Some (CompileExpr com target) -> PropertyGet(target, fiName)
         | None -> PropertyGet(com.RefType fi.DeclaringType, fiName)
      |> fun get -> buildStatement(Assign(expr.DebugInfo, get, value))
   | _ -> None

let private arrayGetSet com _  expr =
   match expr with
   | DerivedPatterns.SpecificCall
      <@ GetArray @> (_,_,[CompileExpr com ar; CompileExpr com i]) ->
      buildExpr <| PropertyGet(ar, i)

   | DerivedPatterns.SpecificCall 
      <@ SetArray @> (_,_,[CompileExpr com ar; CompileExpr com i; CompileExpr com v]) ->
      buildStatement <| Assign(expr.DebugInfo, PropertyGet(ar, i), v)
   | _ -> None

let private isAutoGenerated (pi: PropertyInfo) =
   pi.DeclaringType.GetFields(BindingFlags.All)
   |> Array.exists (fun fi -> fi.Name = (pi.Name + "@"))

let private propertyGetter (com: ICompiler) _ = function
   // F# Custom exceptions
   | Patterns.PropertyGet(Some(Patterns.Coerce(Patterns.Var var, t)), pi, []) ->
      buildExpr <| PropertyGet(JSExpr.Var var, String pi.Name)

   // F# Tuples
   | Patterns.TupleGet(e, i) ->
      buildExpr <| PropertyGet(com.CompileExpr e, Integer i)

   | Patterns.PropertyGet(target, pi, args) as expr ->
      // Autogenerated properties (Records, member val) 
      if isAutoGenerated pi then
         match target with
            | Some (CompileExpr com target) -> PropertyGet(target, String pi.Name)
            | None -> PropertyGet(com.RefType pi.DeclaringType, String pi.Name)
         |> buildExpr
      else
         match target with
         // F# Ref
         | Some target when pi.DeclaringType.Name = typeof<obj ref>.Name ->
            buildExpr <| PropertyGet(com.CompileExpr target, String "contents")
         // F# Unions
         | Some target when FSharpType.IsUnion(pi.DeclaringType, true) &&
            (pi.Name.StartsWith "Item" || pi.Name = "Tag") ->
            buildExpr <| PropertyGet(com.CompileExpr target, String pi.Name)
         | _ ->
            match pi.TryGetAttribute<JSEmitInlineAttribute>() with
            | Some att ->
               let args = match target with Some t -> t::args | None -> args
               buildExpr <| EmitExpr(att.Emit, List.map com.CompileExpr args)
            | None ->
               if FSharpType.IsModule pi.DeclaringType then       // e.g. module Test = let count = 0
                  PropertyGet(com.RefType pi.DeclaringType, String pi.Name)
                  |> buildExpr
               else
                  let call = match target with
                             | Some t -> Expr.Call(t, pi.GetMethod, args)
                             | None -> Expr.Call(pi.SetMethod, args)
                  com.CompileExpr (call.With(expr.DebugInfo)) |> buildExpr
   | _ -> None

let private propertySetter (com: ICompiler) _ = function
   | Patterns.PropertySet(target, pi, args, assignment) as expr ->
      // Autogenerated mutable properties (Records, member val) 
      if isAutoGenerated pi then
         match target with
            | Some (CompileExpr com target) -> PropertyGet(target, String pi.Name)
            | None -> PropertyGet(com.RefType pi.DeclaringType, String pi.Name)
         |> fun get -> buildStatement(Assign(expr.DebugInfo, get, com.CompileExpr assignment))
      else
         match target with
         // F# Ref
         | Some target when pi.DeclaringType.Name = typeof<obj ref>.Name ->
            buildStatement <| Assign(expr.DebugInfo,
                                     PropertyGet(com.CompileExpr target, String "contents"),
                                     com.CompileExpr assignment)
         | _ ->
            match pi.TryGetAttribute<JSEmitInlineAttribute>() with
            | Some att ->
               let args = match target with Some t -> t::args | None -> args
               let emit = sprintf "(%s={%i})" att.Emit (args.Length-1)
               buildStatement <| Do(DebugInfo.Empty, EmitExpr(emit, List.map com.CompileExpr args))
            | None ->
               if FSharpType.IsModule pi.DeclaringType then       // e.g. module Test = let mutable count = 0
                  PropertyGet(com.RefType pi.DeclaringType, String pi.Name)
                  |> fun get -> Assign(expr.DebugInfo, get, com.CompileExpr assignment)
                  |> buildStatement
               else
                  let call = match target with
                             | Some t -> Expr.Call(t, pi.SetMethod, args@[assignment])
                             | None -> Expr.Call(pi.SetMethod, args@[assignment])
                  com.CompileStatement Inplace (call.With(expr.DebugInfo))
                  |> buildStatement
   | _ -> None

let components: CompilerComponent list = [ 
   fieldGetSet
   arrayGetSet
   propertyGetter
   propertySetter
]