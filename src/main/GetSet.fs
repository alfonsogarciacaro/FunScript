module internal FunScript.GetSet

open AST
open InternalCompiler
open System.Reflection
open Microsoft.FSharp.Quotations
open Microsoft.FSharp.Reflection
open Microsoft.FSharp.Core.LanguagePrimitives.IntrinsicFunctions

let private fieldGetSet com _  = function
   | Patterns.FieldGet(target, fi) ->
      // Autogenerated fields will be suffixed with @
      let fiName = fi.Name.Replace("@", "") |> String
      match target with
         | Some (CompileExpr com target) -> PropertyGet(target, fiName)
         | None -> PropertyGet(refType fi.DeclaringType, fiName)
      |> buildExpr
   | Patterns.FieldSet(target, fi, CompileExpr com value) as expr ->
      let fiName = fi.Name.Replace("@", "") |> String
      match target with
         | Some (CompileExpr com target) -> PropertyGet(target, fiName)
         | None -> PropertyGet(refType fi.DeclaringType, fiName)
      |> fun get -> buildStatement(Assign(expr.DebugInfo, get, value))
   | _ -> None

let private arrayGetSet com _  expr =
   match expr with
   | DerivedPatterns.SpecificCall
      <@ GetArray @> (_,_,[CompileExpr com ar; CompileExpr com i]) ->
      buildExpr <| PropertyGet(ar, i)

   | DerivedPatterns.SpecificCall 
      <@ SetArray @> (_,_,[CompileExpr com ar; CompileExpr com i; CompileExpr com v]) ->
      buildStatement <| Assign(expr.DebugInfo, PropertyGet(ar, i), v)
   | _ -> None

let private isAutoGenerated (pi: PropertyInfo) =
   pi.DeclaringType.GetFields(BindingFlags.NonPublic ||| BindingFlags.Instance ||| BindingFlags.Static)
   |> Array.exists (fun fi -> fi.Name = (pi.Name + "@"))

let private propertyGetter (com: Compiler) _ = function
   // F# Custom exceptions
   | Patterns.PropertyGet(Some(Patterns.Coerce(Patterns.Var var, t)), pi, []) ->
      buildExpr <| PropertyGet(refVar var, String pi.Name)

   // F# Tuples
   | Patterns.TupleGet(e, i) ->
      buildExpr <| PropertyGet(com.CompileExpr e, Integer i)

   | Patterns.PropertyGet(target, pi, args) as expr ->
      // Autogenerated properties (Records, member val) 
      if isAutoGenerated pi then
         match target with
            | Some (CompileExpr com target) -> PropertyGet(target, String pi.Name)
            | None -> PropertyGet(refType pi.DeclaringType, String pi.Name)
         |> buildExpr
      else
         match target with
         // F# Ref
         | Some target when pi.DeclaringType.Name = typeof<obj ref>.Name ->
            buildExpr <| PropertyGet(com.CompileExpr target, String "contents")
         // F# Unions
         | Some target when FSharpType.IsUnion pi.DeclaringType &&
            (pi.Name.StartsWith "Item" || pi.Name = "Tag") ->
            buildExpr <| PropertyGet(com.CompileExpr target, String pi.Name)
         | Some target ->
            Expr.Call(target, pi.GetMethod, args).With(expr.DebugInfo)
            |> com.CompileExpr
            |> buildExpr
         | None ->
            Expr.Call(pi.GetMethod, args).With(expr.DebugInfo)
            |> com.CompileExpr
            |> buildExpr
   | _ -> None

let private propertySetter (com: Compiler) _ = function
   | Patterns.PropertySet(target, pi, args, assignment) as expr ->
      // Autogenerated mutable properties (Records, member val) 
      if isAutoGenerated pi then
         match target with
            | Some (CompileExpr com target) -> PropertyGet(target, String pi.Name)
            | None -> PropertyGet(refType pi.DeclaringType, String pi.Name)
         |> fun get -> buildStatement(Assign(expr.DebugInfo, get, com.CompileExpr assignment))
      else
         match target with
         // F# Ref
         | Some target when pi.DeclaringType.Name = typeof<obj ref>.Name ->
            buildStatement <| Assign(expr.DebugInfo,
                                     PropertyGet(com.CompileExpr target, String "contents"),
                                     com.CompileExpr assignment)
         | Some target ->
            Expr.Call(target, pi.SetMethod, args@[assignment]).With(expr.DebugInfo)
            |> com.CompileExpr
            |> buildExpr
         | None ->
            Expr.Call(pi.SetMethod, args@[assignment]).With(expr.DebugInfo)
            |> com.CompileExpr
            |> buildExpr
   | _ -> None

let components: CompilerComponent list = [ 
   fieldGetSet
   arrayGetSet
   propertyGetter
   propertySetter
]