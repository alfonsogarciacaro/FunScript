module internal FunScript.Constructors

open AST
open InternalCompiler
open System.Reflection
open Microsoft.FSharp.Quotations
open Microsoft.FSharp.Reflection

let rec private foldi i state f source  =
   if i = (Array.length source) then state
   else foldi (i+1) (f i state source.[i]) f source

let compileUciConstructor (uci: UnionCaseInfo) =
   let this, pis, di = Var("_this", typeof<obj>), uci.GetFields(), DebugInfo.Empty
   AssignGlobal(
      PropertyGet(refType uci.DeclaringType, Reference(Case uci)),
      if pis.Length = 0 then
         Lambda([],
            Let(di, this, New(refType uci.DeclaringType, []),
               Sequential(Assign(di, PropertyGet(refVar this, String "Tag"), Integer uci.Tag),
                  Return(di, refVar this))))
      else
         let vars = pis |> Array.mapi (fun i _ -> Var(sprintf "a%i" i, typeof<obj>))
         let assign i = Assign(di, PropertyGet(refVar this, String pis.[i].Name), refVar vars.[i])
         pis
         |> foldi 0 (Return(di, refVar this)) (fun i state _ -> Sequential(assign i, state))
         |> fun assignments ->
            Lambda(List.ofArray vars,
               Let(di, this, New(refType uci.DeclaringType, []),
                  Sequential(Assign(di, PropertyGet(refVar this, String "Tag"), Integer uci.Tag), assignments))))

let private compileObjectConstructor (com: Compiler) (ci: ConstructorInfo) =
   let jse =
      match ci.TryGetAttribute<JSEmitAttribute>() with
      | Some att -> 
         let vars = ci.GetParameters() |> Seq.map (fun p -> Var(p.Name, typeof<obj>)) |> Seq.toList
         Lambda(vars, Do(DebugInfo.Empty, EmitExpr(att.Emit, List.map refVar vars)))
      | None ->
         match Expr.TryGetReflectedDefinition ci with
         | Some e ->
            match e with
            | DerivedPatterns.Lambdas(vars, body) ->
               let vars = vars |> List.concat |> List.filter (fun v -> v.Type <> typeof<unit>)
               Applications.getMethGenArgDefinitions ci              // Receive also generic arguments
               |> List.map (fun a -> Var("$" + a.Name, typeof<obj>))
               |> List.append <| List.rev vars                       // DerivedPatterns.Lambdas reverses the var list
               |> fun vars -> Lambda(vars, com.CompileStatement Inplace body)
            | _ ->
               failwithf "Please report: DerivedPatterns.Lambdas doesn't match %s constructor"
                         ci.DeclaringType.Name
         | None -> 
            failwithf "Type %s is not tagged with JS attribute" ci.DeclaringType.Name
   AssignGlobal(refType ci.DeclaringType, jse)

let private genConstructor (t: System.Type) (pis: PropertyInfo[]) =
   if pis.Length = 0
   then AssignGlobal(refType t, Lambda([], Empty))
   else 
      let this = Var("this", typeof<obj>)
      let vars = pis |> Array.mapi (fun i _ -> Var(sprintf "a%i" i, typeof<obj>))
      let assign i = Assign(DebugInfo.Empty,
                        PropertyGet(refVar this, String pis.[i].Name),
                        refVar vars.[i])
      pis
      |> foldi 1 (assign 0) (fun i state _ -> Sequential(state, assign i))
      |> fun assignments -> AssignGlobal(refType t, Lambda(List.ofArray vars, assignments))

let compileConstructor com t =
   let cons =
      if   FSharpType.IsUnion  t then AssignGlobal(refType t, Lambda([], Empty))
      elif FSharpType.IsRecord t then genConstructor t (FSharpType.GetRecordFields t)
      elif FSharpType.IsExceptionRepresentation t then genConstructor t (FSharpType.GetExceptionFields t)
      else
         match t.GetConstructors() with
         | [||] -> AssignGlobal(refType t, Object []) // Static types, modules
         | cis -> compileObjectConstructor com cis.[0]
   // Static fields
   t.GetFields(BindingFlags.Static ||| BindingFlags.Public ||| BindingFlags.NonPublic)
   |> Array.fold (fun (cons: JSStatement) fi ->
      Sequential(cons, AssignGlobal(refType t, String fi.Name))) cons

let private constructInstance com ret = function
   // TODO: Use 'undefined' instead of 'null' for None? It'd make more sense for optional parameters.
   // (Update JSEmit expressions in FunScript.Core.Option if this changes)
   | Patterns.NewUnionCase (uci, args) when uci.DeclaringType.Name = typeof<obj option>.Name ->
      buildExpr <| match args with [CompileExpr com arg] -> arg | _ -> Null

   | Patterns.NewUnionCase (uci, args) ->
      buildExpr <| Apply(PropertyGet(refType uci.DeclaringType, Reference(Case uci)),
                         List.map com.CompileExpr args)
   
   // TODO: Check if the problem with quotations generated by type providers is still happening (see PatternsExt)
   | PatternsExt.NewRecord (t, args) ->
      let t = Applications.getGenTypeDef t
      buildExpr <| New(refType t, List.map com.CompileExpr args)

   | PatternsExt.NewObject (ci, args) ->
      let ci = Applications.getGenMethodDef ci :?> ConstructorInfo
      let args = List.map com.CompileExpr args
      match ret with
      | Inplace ->
         buildStatement <|
            // Ignore primary constructors calling obj or System.Exception as base
            if ci.DeclaringType = typeof<obj> || ci.DeclaringType = typeof<System.Exception>
            then Empty
            else Do(DebugInfo.Empty,
                  Apply(PropertyGet(refType ci.DeclaringType, String "call"),
                        EmitExpr("this",[])::args))
      | _ ->
         buildExpr <|
            let genArgs = Applications.getMethGenArgs ci |> List.map refType
            if ci = ci.DeclaringType.GetConstructors().[0] then            // Primary constructor
               match ci.TryGetAttribute<JSEmitInlineAttribute>() with
               | Some att -> New(EmitExpr(att.Emit, []), args)
               | None -> New(refType ci.DeclaringType, args@genArgs)
            else
               Apply(refMethodCall(ci, None), args@genArgs)
   | _ -> None

let components: CompilerComponent list = [
   constructInstance
]
