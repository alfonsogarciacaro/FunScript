namespace FunScript

open System.Reflection
open Microsoft.FSharp
open Microsoft.FSharp.Compiler.SourceCodeServices
open Microsoft.FSharp.Compiler.SourceCodeServices.BasicPatterns

[<AutoOpen>]
module ReflectionExt =
//   type BindingFlags with
//      static member All
//         with get() = BindingFlags.Public   ||| BindingFlags.NonPublic |||
//                      BindingFlags.Instance ||| BindingFlags.Static

  let private getTypeFullname (t: System.Type) =
    let rec parentName (t: System.Type) =
      if t.IsNested then (parentName t.DeclaringType) + t.DeclaringType.Name + "." else ""
    let ns = if System.String.IsNullOrEmpty(t.Namespace) then "" else t.Namespace + "."
    ns + (parentName t) + t.Name

  let (|SpecificCall|_|) (templateParameter: Quotations.Expr) =
    match templateParameter with
    | (Quotations.DerivedPatterns.Lambdas(_,Quotations.Patterns.Call(_,minfo1,_))
    | Quotations.Patterns.Call(_,minfo1,_)) ->
      try
        minfo1.DeclaringType.GetMethod(minfo1.Name) |> ignore
      with  _ -> failwithf "%s is overloaded, SpecificCall doesn't support this" minfo1.Name
      let minfo1Fullname = (getTypeFullname minfo1.DeclaringType) + minfo1.Name
      (fun (call: FSharpExpr) -> 
          match call with
          | Call(target,minfo2,typeGenArgs,methGenArgs,args)
            when minfo1Fullname = (minfo2.EnclosingEntity.FullName + minfo2.CompiledName) ->
            Some(target, typeGenArgs, methGenArgs, args)
          | _ -> None)
    | _ -> failwith "Invalid template passed to SpecificCall"


  type FSharpMemberOrFunctionOrValue with
    member self.TryGetAttribute<'attr>() =
      self.Attributes
      |> Seq.tryPick (fun x ->
        if x.AttributeType.CompiledName = typeof<'attr>.Name
        then Some (x.ConstructorArguments |> Seq.map snd |> Seq.toList)
        else None)

  type FSharpParameter with
    member self.TryGetAttribute<'attr>() =
      self.Attributes
      |> Seq.tryFind (fun x ->
        x.AttributeType.CompiledName = typeof<'attr>.Name)

  type FSharpType with
    member self.TryGetAttribute<'attr>() =
      match self.HasTypeDefinition with
      | false -> None                           // TODO: Check if it's Type Abbreviation?
      | true -> self.TypeDefinition.Attributes
                |> Seq.tryFind (fun x ->
                  x.AttributeType.CompiledName = typeof<'attr>.Name)

(*
[<AutoOpen>]
module internal PatternsExt = 
   // In quotations generated by type provider code, records and
   // objects are mixed up a bit (???) so this corrects the behaviour.

   let (|NewObject|_|) = function
      | Patterns.NewObject(ctor, args) ->
         if FSharpType.IsRecord(ctor.DeclaringType, BindingFlags.All) then None
         else Some(ctor, args)
      | _ -> None
   
   let (|NewRecord|_|) = function
      | Patterns.NewRecord(typ, args) -> Some(typ, args)
      | Patterns.NewObject(ctor, args) ->
         if FSharpType.IsRecord(ctor.DeclaringType, BindingFlags.All) then 
           Some(ctor.DeclaringType, args)
         else None
      | _ -> None
*)

(*
[<AutoOpen>]
module internal ExprExt =
   type DebugInfo =
      { file: string; line: int; col: int }
      static member Empty = { file=""; line=0; col=0 }

   // From http://stackoverflow.com/questions/11772046/file-and-line-numbers-in-f-code-quotations
   let private getDebugInfo (e: Expr) = 
       let (|Val|_|) = function
           | Patterns.Value(:? 't as v,_) -> Some v
           | _ -> None
       e.CustomAttributes
       |> List.tryPick (function
         | Patterns.NewTuple
            [ Val("DebugRange"); Patterns.NewTuple
               [ Val(file:string); Val(startLine:int); Val(startCol:int); _; _] ] ->
            Some { file=file; line=startLine; col=startCol }
         | _ -> None)
       |> function
         | Some di -> di
         | None -> { file=""; line=0; col=0 } // TODO: Throw exception instead?

   let private setDebugInfo (e: Expr) (dinfo: DebugInfo) =
      typeof<Expr>.GetField("attribs", BindingFlags.All).SetValue(e,
         [Expr.NewTuple [Expr.Value("DebugRange")
                         Expr.NewTuple [Expr.Value dinfo.file
                                        Expr.Value dinfo.line
                                        Expr.Value dinfo.col
                                        Expr.Value 0
                                        Expr.Value 0]]])

   type Expr with
      member expr.DebugInfo = getDebugInfo expr
      member expr.With dinfo =
         setDebugInfo expr dinfo
         expr
*)

(*
[<AutoOpen>]
module internal FSharpExprExt =
   open Microsoft.FSharp.Compiler
   open Microsoft.FSharp.Compiler.SourceCodeServices

   type DebugInfo =
      { file: int; line: int; col: int }
      static member Empty = { file=(-1); line=(-1); col=(-1) }

   let private setDebugInfo (e: FSharpExpr) (dinfo: DebugInfo) =
      let pos = Range.mkPos dinfo.line dinfo.col
      // We're not interested in end position, make it same as beginning
      let r = Range.mkFileIndexRange dinfo.file pos pos
      typeof<FSharpExpr>.GetField("m", BindingFlags.All).SetValue(e, r)

   type FSharpExpr with
      member e.DebugInfo = { file=e.Range.FileIndex; line=e.Range.StartLine; col=e.Range.StartColumn}
      member e.With dinfo = let e = setDebugInfo e dinfo in e
*)
